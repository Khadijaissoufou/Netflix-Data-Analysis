# -*- coding: utf-8 -*-
"""CODE EDA NEXTFLIX

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wemRFta1xn9xBfo3O6exnBW9uiPon-Qr
"""

# Importation de pandas
import pandas as pd

# Lecture du fichier 'netflix_titles.csv'
df = pd.read_csv('netflix_titles.csv')

# Vérification
print("Dimensions du dataset :", df.shape)
print("\nAperçu des données :")
df.head()


# Affichage des informations générales sur le dataset
print("=== INFORMATIONS GÉNÉRALES ===")
print(f"Dimensions du dataset : {df.shape[0]} lignes et {df.shape[1]} colonnes")
print(f"\nType de données par colonne :")
print(df.dtypes)

print("\n=== VALEURS MANQUANTES ===")
for colonne in df.columns:
    nb_manquants = df[colonne].isnull().sum()
    pourcentage = (nb_manquants / len(df)) * 100
    print(f"{colonne}: {nb_manquants} manquants ({pourcentage:.1f}%)")

print("\n=== STATISTIQUES DESCRIPTIVES ===")
print(df.describe(include='all'))

print("\n=== VALEURS UNIQUES PAR COLONNE ===")
for colonne in df.columns:
    nb_uniques = df[colonne].nunique()
    print(f"{colonne}: {nb_uniques} valeurs uniques")

#  NETTOYAGE ET SÉPARATION
import numpy as np


print("=== ÉTAPE 1 : CONVERSION DES DATES ===")

# 1. Convertir 'date_added' en format datetime
df['date_added'] = pd.to_datetime(df['date_added'], errors='coerce')

# 2. Extraire année et mois
df['year_added'] = df['date_added'].dt.year
df['month_added'] = df['date_added'].dt.month

print("Conversion date_added terminée")
print(f"Exemple: {df['date_added'].iloc[0]} → année: {df['year_added'].iloc[0]}, mois: {df['month_added'].iloc[0]}")

print("\n=== ÉTAPE 2 : SÉPARATION DE LA COLONNE DURATION ===")

# 3. Nettoyer la colonne 'duration'
# Méthode robuste pour extraire les nombres
def extract_number(text):
    if pd.isna(text):
        return np.nan
    # Trouver tous les chiffres dans la chaîne
    import re
    numbers = re.findall(r'\d+', str(text))
    return float(numbers[0]) if numbers else np.nan

# Appliquer la fonction
df['duration_numeric'] = df['duration'].apply(extract_number)

# Créer deux colonnes séparées
df['duration_min'] = np.where(df['type'] == 'Movie', df['duration_numeric'], np.nan)
df['duration_seasons'] = np.where(df['type'] == 'TV Show', df['duration_numeric'], np.nan)

# Supprimer la colonne temporaire
df = df.drop('duration_numeric', axis=1)

print("Séparation duration terminée")
print("\nVérification :")
print(df[['type', 'duration', 'duration_min', 'duration_seasons']].head(10))

print(f"\nStatistiques :")
print(f"Films avec durée : {df['duration_min'].notna().sum()}")
print(f"Séries avec saisons : {df['duration_seasons'].notna().sum()}")

print("\n=== ÉTAPE 3 : GESTION DES VALEURS MANQUANTES ===")

# 4. Remplacer les valeurs manquantes pour les colonnes catégorielles
colonnes_categorielles = ['director', 'cast', 'country', 'rating']
for col in colonnes_categorielles:
    nb_avant = df[col].isnull().sum()
    df[col] = df[col].fillna('Unknown')
    nb_apres = df[col].isnull().sum()
    print(f"{col}: {nb_avant} → {nb_apres} valeurs manquantes")

# Pour date_added (peu de valeurs manquantes), on garde les NaN pour l'instant
nb_date_manquantes = df['date_added'].isnull().sum()
print(f"\ndate_added: {nb_date_manquantes} valeurs manquantes (gardées pour l'instant)")

print("\n=== ÉTAPE 4 : PRÉPARATION DES COLONNES DE LISTES ===")

# 5. Préparer les colonnes de listes pour l'analyse
def prepare_list_column(column_value):
    if pd.isna(column_value) or column_value == 'Unknown':
        return []
    # Séparer par virgule et nettoyer les espaces
    return [item.strip() for item in str(column_value).split(',')]

df['genres_list'] = df['listed_in'].apply(prepare_list_column)
df['countries_list'] = df['country'].apply(prepare_list_column)
df['cast_list'] = df['cast'].apply(prepare_list_column)
df['director_list'] = df['director'].apply(prepare_list_column)

print("Préparation des listes terminée")
print("\nExemple de genres_list:")
print(df['genres_list'].iloc[0])
print("\nExemple de countries_list:")
print(df['countries_list'].iloc[0])

print("\n=== RÉCAPITULATIF ===")
print(f"Dataset après nettoyage : {df.shape[0]} lignes, {df.shape[1]} colonnes")
print("\nNouvelles colonnes créées :")
nouvelles_colonnes = ['year_added', 'month_added', 'duration_min', 'duration_seasons',
                      'genres_list', 'countries_list', 'cast_list', 'director_list']
for col in nouvelles_colonnes:
    print(f"  - {col}")

print("\nValeurs manquantes restantes :")
for col in df.columns:
    missing = df[col].isnull().sum()
    if missing > 0:
        print(f"  {col}: {missing} ({missing/len(df)*100:.1f}%)")

# CORRECTION DES PROBLÈMES IDENTIFIÉS

print("=== CORRECTION DES PROBLÈMES RESTANTS ===\n")

# 1. GESTION DES DATES MANQUANTES
print("1. Gestion des dates manquantes :")
print(f"   Avant : {df['date_added'].isna().sum()} dates manquantes")

# Pour les analyses temporelles, créer un DataFrame sans les dates manquantes
df_clean_dates = df.dropna(subset=['date_added']).copy()
print(f"   Après nettoyage pour analyse temporelle : {len(df_clean_dates)} lignes")

# 2. GESTION DES DURÉES MANQUANTES
print("\n2. Gestion des durées manquantes :")
print(f"   Durées manquantes dans 'duration' : {df['duration'].isna().sum()}")

# Remplir les durées manquantes basées sur la moyenne par type
for type_content in ['Movie', 'TV Show']:
    mask = (df['type'] == type_content) & (df['duration'].isna())
    if type_content == 'Movie':
        avg_duration = df[df['type'] == 'Movie']['duration_min'].mean()
        print(f"   Durée moyenne des films : {avg_duration:.1f} min")
    else:
        avg_seasons = df[df['type'] == 'TV Show']['duration_seasons'].mode()[0]
        print(f"   Mode du nombre de saisons des séries : {avg_seasons}")

#3. ANALYSE EXPLORATOIRE DES DONNÉES CORRIGÉES
import matplotlib.pyplot as plt
import seaborn as sns

print("\n" + "="*60)
print("ANALYSE EXPLORATOIRE DES DONNÉES NETTOYÉES")
print("="*60)

# A. RÉPARTITION GÉNÉRALE
print("\nA. RÉPARTITION GÉNÉRALE")

# 1. Distribution Films vs Séries
plt.figure(figsize=(10, 6))
type_counts = df['type'].value_counts()
colors = ['#E50914', '#221F1F']
plt.pie(type_counts.values, labels=type_counts.index, autopct='%1.1f%%',
        colors=colors, startangle=90, explode=(0.05, 0))
plt.title('Distribution des Films vs Séries TV', fontsize=14, fontweight='bold')
plt.show()

# 2. Évolution des ajouts sur Netflix par année
plt.figure(figsize=(12, 6))
if not df_clean_dates.empty:
    added_by_year = df_clean_dates['year_added'].value_counts().sort_index()
    plt.plot(added_by_year.index, added_by_year.values, marker='o',
             linewidth=2, color='#E50914', markersize=6)
    plt.xlabel('Année', fontsize=12)
    plt.ylabel('Nombre d\'ajouts', fontsize=12)
    plt.title('Évolution des ajouts sur Netflix par année', fontsize=14, fontweight='bold')
    plt.grid(True, alpha=0.3)
    plt.show()

# B. ANALYSE DES GENRES
print("\nB. ANALYSE DES GENRES")

# Compter tous les genres
from collections import Counter
all_genres = []
for genres in df['genres_list']:
    all_genres.extend(genres)

genre_counts = Counter(all_genres)
top_genres = pd.DataFrame(genre_counts.most_common(15), columns=['Genre', 'Count'])

print(f"Nombre total de genres uniques : {len(genre_counts)}")

plt.figure(figsize=(12, 8))
bars = plt.barh(top_genres['Genre'], top_genres['Count'], color='#E50914')
plt.xlabel('Nombre de productions', fontsize=12)
plt.title('Top 15 des genres les plus populaires', fontsize=14, fontweight='bold')
plt.gca().invert_yaxis()

for bar in bars:
    width = bar.get_width()
    plt.text(width + 5, bar.get_y() + bar.get_height()/2,
             f'{int(width)}', va='center', fontsize=10)
plt.tight_layout()
plt.show()

# C. ÉVOLUTION DES GENRES DANS LE TEMPS
print("\nC. ÉVOLUTION DES GENRES DANS LE TEMPS")

# Prendre les 5 genres les plus populaires
top_5_genres_names = top_genres['Genre'].head(5).tolist()

# Créer un DataFrame pour l'évolution
genre_evolution = pd.DataFrame()

for genre in top_5_genres_names:
    mask = df['listed_in'].str.contains(genre, na=False)
    genre_by_year = df[mask]['release_year'].value_counts().sort_index()
    genre_evolution[genre] = genre_by_year

genre_evolution = genre_evolution.fillna(0)

plt.figure(figsize=(14, 8))
for i, genre in enumerate(top_5_genres_names):
    plt.plot(genre_evolution.index, genre_evolution[genre],
             marker='o', linewidth=2, markersize=4, label=genre)

plt.xlabel('Année de sortie', fontsize=12)
plt.ylabel('Nombre de productions', fontsize=12)
plt.title('Évolution des 5 genres les plus populaires', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# D. ANALYSE PAR PAYS
print("\nD. ANALYSE PAR PAYS")

all_countries = []
for countries in df['countries_list']:
    all_countries.extend(countries)

country_counts = Counter(all_countries)
top_countries = pd.DataFrame(country_counts.most_common(15), columns=['Pays', 'Count'])

print(f"Nombre total de pays uniques : {len(country_counts)}")

plt.figure(figsize=(12, 8))
bars = plt.barh(top_countries['Pays'], top_countries['Count'], color='#221F1F')
plt.xlabel('Nombre de productions', fontsize=12)
plt.title('Top 15 des pays producteurs', fontsize=14, fontweight='bold')
plt.gca().invert_yaxis()

for bar in bars:
    width = bar.get_width()
    plt.text(width + 5, bar.get_y() + bar.get_height()/2,
             f'{int(width)}', va='center', fontsize=10)
plt.tight_layout()
plt.show()

# E. COMPARAISON ENTRE LES PAYS (TOP 3)
print("\nE. COMPARAISON ENTRE LES PAYS (TOP 3)")

top_3_countries_names = top_countries['Pays'].head(3).tolist()

# Créer un graphique comparatif
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

for idx, country in enumerate(top_3_countries_names):
    # Filtrer pour ce pays
    country_df = df[df['country'].str.contains(country, na=False)]

    # Distribution des types
    type_dist = country_df['type'].value_counts()
    axes[idx].pie(type_dist.values, labels=type_dist.index, autopct='%1.1f%%',
                  colors=['#E50914', '#221F1F'], startangle=90)
    axes[idx].set_title(f'Distribution Films/Séries\n{country}', fontweight='bold')

plt.suptitle('Comparaison des 3 principaux pays producteurs', fontsize=16, fontweight='bold', y=1.05)
plt.tight_layout()
plt.show()

# F. ANALYSE DES DURÉES
print("\nF. ANALYSE DES DURÉES")

# Séparer les films et séries
films = df[df['type'] == 'Movie']
series = df[df['type'] == 'TV Show']

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Histogramme des durées de films
axes[0, 0].hist(films['duration_min'].dropna(), bins=30, edgecolor='black',
                alpha=0.7, color='#E50914')
axes[0, 0].set_xlabel('Durée (minutes)', fontsize=11)
axes[0, 0].set_ylabel('Nombre de films', fontsize=11)
axes[0, 0].set_title('Distribution des durées des films', fontsize=12, fontweight='bold')
axes[0, 0].grid(True, alpha=0.3)

# Boxplot des durées de films
axes[0, 1].boxplot(films['duration_min'].dropna(), vert=False, patch_artist=True,
                   boxprops=dict(facecolor='#E50914', alpha=0.7))
axes[0, 1].set_xlabel('Durée (minutes)', fontsize=11)
axes[0, 1].set_title('Boxplot des durées des films', fontsize=12, fontweight='bold')
axes[0, 1].grid(True, alpha=0.3, axis='x')

# Distribution du nombre de saisons
season_counts = series['duration_seasons'].value_counts().sort_index().head(10)
axes[1, 0].bar(season_counts.index.astype(str), season_counts.values,
               color='#221F1F', edgecolor='black')
axes[1, 0].set_xlabel('Nombre de saisons', fontsize=11)
axes[1, 0].set_ylabel('Nombre de séries', fontsize=11)
axes[1, 0].set_title('Distribution du nombre de saisons (top 10)', fontsize=12, fontweight='bold')
axes[1, 0].tick_params(axis='x', rotation=45)
axes[1, 0].grid(True, alpha=0.3, axis='y')

# Boxplot du nombre de saisons
axes[1, 1].boxplot(series['duration_seasons'].dropna(), vert=False, patch_artist=True,
                   boxprops=dict(facecolor='#221F1F', alpha=0.7))
axes[1, 1].set_xlabel('Nombre de saisons', fontsize=11)
axes[1, 1].set_title('Boxplot du nombre de saisons', fontsize=12, fontweight='bold')
axes[1, 1].grid(True, alpha=0.3, axis='x')

plt.tight_layout()
plt.show()

# G. ANALYSE DES RATINGS
print("\nG. ANALYSE DES RATINGS")

plt.figure(figsize=(12, 6))
rating_counts = df['rating'].value_counts()
bars = plt.bar(rating_counts.index, rating_counts.values, color='#E50914', edgecolor='black')
plt.xlabel('Classification', fontsize=12)
plt.ylabel('Nombre de productions', fontsize=12)
plt.title('Distribution des ratings', fontsize=14, fontweight='bold')
plt.xticks(rotation=45, ha='right')

# Ajouter les valeurs sur les barres
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 20,
             f'{int(height)}', ha='center', fontsize=9)

plt.tight_layout()
plt.show()

# H. ANALYSE DES ACTEURS LES PLUS FRÉQUENTS
print("\nH. ANALYSE DES ACTEURS LES PLUS FRÉQUENTS")

all_actors = []
for actors in df['cast_list']:
    all_actors.extend(actors)

actor_counts = Counter(all_actors)
top_actors = pd.DataFrame(actor_counts.most_common(10), columns=['Acteur', 'Apparitions'])

print("Top 10 des acteurs les plus fréquents :")
print(top_actors)

plt.figure(figsize=(12, 6))
bars = plt.barh(top_actors['Acteur'], top_actors['Apparitions'], color='#221F1F')
plt.xlabel('Nombre d\'apparitions', fontsize=12)
plt.title('Top 10 des acteurs les plus fréquents', fontsize=14, fontweight='bold')
plt.gca().invert_yaxis()

for bar in bars:
    width = bar.get_width()
    plt.text(width + 0.5, bar.get_y() + bar.get_height()/2,
             f'{int(width)}', va='center', fontsize=10)
plt.tight_layout()
plt.show()

# I. ANALYSE DE L'ÉVOLUTION DE LA PRODUCTION PAR DÉCENNIE
print("\nI. ANALYSE DE L'ÉVOLUTION DE LA PRODUCTION PAR DÉCENNIE")

# Créer une colonne décennie si elle n'existe pas déjà
if 'decade' not in df.columns:
    df['decade'] = (df['release_year'] // 10) * 10

decade_counts = df['decade'].value_counts().sort_index()

plt.figure(figsize=(12, 6))
bars = plt.bar(decade_counts.index.astype(str), decade_counts.values, color='#E50914')
plt.xlabel('Décennie', fontsize=12)
plt.ylabel('Nombre de productions', fontsize=12)
plt.title('Distribution des productions par décennie', fontsize=14, fontweight='bold')

for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 20,
             f'{int(height)}', ha='center', fontsize=10)

plt.tight_layout()
plt.show()

print("\n" + "="*60)
print("ANALYSE EXPLORATOIRE TERMINÉE")
print("="*60)

print("\nRÉSUMÉ DES ANALYSES EFFECTUÉES :")
print("1. Distribution générale (Films vs Séries)")
print("2. Évolution temporelle des ajouts sur Netflix")
print("3. Analyse des genres (popularité et évolution)")
print("4. Analyse par pays (distribution et comparaison)")
print("5. Analyse des durées (films et séries)")
print("6. Analyse des ratings (classifications)")
print("7. Analyse des acteurs les plus fréquents")
print("8. Évolution de la production par décennie")